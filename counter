#!/bin/bash

# ----
# script-o-counter - a script to count 1.0 and 2.x SuiteScript files and collect code statistics. 
# 
# Note: This script calculates the correct values for 2.x code, since it is a lot easier to find 2.x code indiactors that would
# yield an almost definite match. 1.0 code values would be slightly overestimated due to the fact that some non-SuiteCloud code looks like 1.0 code.
# This counter also treats regular javascript/typescript as 1.0 code. All of that is due to the lack of consistency in 1.0 code indicators.
#
# Author: Seymour Pashayev
# SeymourP@solution-source.net
# github: gordonsamh@gmail.com
# ----

# -------- FUNCTION DEFINITIONS -------- #

# Define "usage" function to display script usage
usage() {
	echo "--------"
	echo "Script-o-counter - a script to count through 1.0 and 2.x SuiteScript files and collect code statistics." 
	echo "Run in the directory where you want to collect code statistics."
	echo "--------"
	echo "Usage: $0 [-h] [-r]"
	echo "[-h]: Display this menu."
	echo "[-r]: Apply recursive directory search (look through files in child directories as well)."

	exit 1
}

# Function to check for 2.x code indicators:
# 
# Arguments: file - file to be parsed for code indicators. 
# Return 0 if 2.x code indicators are found, 1 otherwise.
function checkFor2XIndicators() {
	# Pass the filename into the function	
	local filename="$1"

	# Define the 2.x patterns to look for 
	local pattern="@NApiVersion 2.x\|@NApiVersion 2.1\|define(\['N/\|define(\[\],"

	if [ -f "$filename" ]; then
		# Grep through the file for 2.x code patterns and return 0 if the pattern is found 
       		if grep -q "$pattern" "$filename"; then
			return 0;
		else 
			return 1;
		fi

    	else
        	echo "File not found: $filename"
		return 1
    	fi
}

# Formats file-name output to only print out the file-name w/o the working directory traversal
# This is done to simplify the output.
function cutFileFromPath() {
	local fullFilePath="$1"
	echo $sed -n -e '/\.js$/s/.*\///p' "$fullFilePath"
}

# Function to populate file information
# Arguments: array_name full_path
populateFileInfo() {
    	local array_name="$1"
    	local full_path="$2"
	local filename=$(echo "$full_path" | grep -oE '[^/]+$' | sed 's/\./_/g')
    	local line_count=$(wc -l < "$full_path")
    
   	# Check if the file is already in the array and if the line count is different
    	local -n file_info_array="$array_name"
    	if [[ -z "${file_info_array[$filename]}" || $line_count -ne "${file_info_array[$filename]}" ]]; then
        	file_info_array["$filename"]="$line_count"

		# Increment the total line count based on the which code version array belongs to 
        	if [[ $array_name == "files_1X" ]]; then
            		((total_lines_1X += line_count))
        	elif [[ $array_name == "files_2X" ]]; then
            		((total_lines_2X += line_count))
        	fi
    	fi
}

# Iterate through each file and process it for 2.x and 1.0 code.
#
# Arguments: file - filename of the file to be processed
# Return: void
processFile() {
	local file="$1"

    	# Check for 2.x indicators in the beginning
    	if checkFor2XIndicators "$file"; then
       	
		#debug
		echo $file

		# Flag file as 2.X
		populateFileInfo "files_2X" "$file"

    	elif [ -f "$file" ]; then
      		
		#debug
		echo $file

		# Flag file as 1.0
		populateFileInfo "files_1X" "$file"	
    	fi
}

# -------- APPLICATION LOGIC --------

# Initialize menu flags
recursive=false
output_lines=true
output_files=true

# Process command line options
while getopts "rh" opt; do
	case $opt in
        	r)
            		recursive=true
			;;
        	h|\?)
            		usage
            		;;
    	esac
done

# Check if flags were supplied
if ! $output_lines && ! $output_files; then
    usage
fi

# Initialize counters for 1.0 and 2.X lines of code
total_lines_1X=0
total_lines_2X=0

# Instantiate arrays to store files of type 1.0 code and 2.x code
# Data structure to hold base_filename & the line count
declare -A files_1X
declare -A files_2X

# Define recursive and non-resursive search using find (Recursive if the -r flag is set)
if $recursive; then
	# Recursive search	
	fileList="find . -type f -name '*.js' -print0"
else
	# Non-recursive search
	fileList="find . -maxdepth 1 -type f -name '*.js' -print0"
fi

# Iterate through each file found using "find" tool
while IFS= read -r -d '' file; do
    	processFile "$file"
done < <(eval "$fileList")

# Output Formatting
echo
echo "----- Code Statistics -----"
echo

if [ output_files ]; then
	
	# Print file information for 1.x code
	echo "===================="
	echo "   1.x Code Files   "
	echo "===================="
	for filename in "${!files_1X[@]}"; do
    		line_count="${files_1X[$filename]}"
    		echo "$filename: $line_count" 
   		echo
	done

	# Print file information for 2.x code
	echo "===================="
	echo "   2.x Code Files   "
	echo "===================="
	for filename in "${!files_2X[@]}"; do
    		line_count="${files_2X[$filename]}"
    		echo "$filename: $line_count"
    		echo
	done

	echo "---------------------------"

fi

if [ output_lines ]; then

	# Print out the number of lines of both 1.0 and 2.x code.
	echo "Total #lines 1.0 code: $total_lines_1X"
	echo "Total #lines 2.x code: $total_lines_2X"

fi

echo "---------------------------"


