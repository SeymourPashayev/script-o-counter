#!/bin/bash

# ----
# script-o-counter - a script to count 1.0 and 2.x SuiteScript files and collect code statistics. 
# 
# Note: This script calculates the correct values for 2.x code, since it is a lot easier to find 2.x code indiactors that would
# yield an almost definite match. 1.0 code values would be slightly overestimated due to the fact that some non-SuiteCloud code looks like 1.0 code.
# This counter also treats regular javascript/typescript as 1.0 code. All of that is due to the lack of consistency in 1.0 code indicators.
#
# Author: Seymour Pashayev
# SeymourP@solution-source.net
# github: gordonsamh@gmail.com
# ----

# Define usage function to display script usage
usage() {
	echo "--------"
	echo "Script-o-counter - a script to count through 1.0 and 2.x SuiteScript files and collect code statistics." 
	echo "Run in the directory where you want to collect code statistics."
	echo "--------"
	echo "Usage: $0 [-h] [-r] [-l] [-f]"
	echo "[-h]: Display this menu."
	echo "[-r]: Apply recursive directory search (look through files in child directories as well)."
	echo "[-l]: Show line numbers for each code category"
	echo "[-f]: Show filenames for each code category"
	echo
	echo "Either -l or -f is required to run the counter"

	exit 1
}

# Function to check for 2.x code indicators:
# 
# Arguments: file - file to be parsed for code indicators. 
# Return 0 if 2.x code indicators are found, 1 otherwise.
function checkFor2XIndicators() {
	# Pass the filename into the function	
	local filename="$1"

	# Define the pattern(s) to look for
	# TODO: There's potential to add more 2.x code indicators to the grep search
	local pattern="@NApiVersion 2.x\|@NApiVersion 2.1\|define(\['N/\|define(\[\],"

	if [ -f "$filename" ]; then
		# Grep through the file for 2.x code patterns and return 0 if the pattern is found 
       		if grep -q "$pattern" "$filename"; then
			return 0;
		else 
			return 1;
		fi

    	else
        	echo "File not found: $filename"
		return 1
    	fi
}

# Function to check for 1.0 code indicators:
# 
# Arguments: line - line to be parsed for code indicators 
# Return 0 if 1.0 code indicators are found, 1 otherwise.
#function checkFor1XIndicators() {
    # Use regular expressions to match 1.0 indicators within the line
    #
    # !There might be no valid consistent 1.0 code indicators that would work for indentifying a given file
    # !Therefore any values counting 1.0 code would have to be collected as "fallback" values from code that was
    # !identified as non-2.x code in the first step of the loop.
#}

# Initialize menu flags
recursive=false
output_lines=false
output_files=false

# Process command line options
while getopts "rlfh" opt; do
    case $opt in
        r)
            recursive=true
            ;;
        l)
            output_lines=true
            ;;
        f)
            output_files=true
            ;;
        h|\?)
            usage
            ;;
    esac
done

# Check if no flags were supplied
if ! $output_lines && ! $output_files; then
    usage
fi

# Initialize counters for 1.0 and 2.X lines of code
total_lines_1X=0
total_lines_2X=0

# Instantiate arrays to store files of type 1.0 code and 2.x code
files_1X=()
files_2X=()

# TODO: Implement recursive search and the flag for it
# Iterate through each file
for file in *.js; do
   
    	# Check for 2.x indicators in the beginning
    	if checkFor2XIndicators "$file"; then
        
		# Flag as 2.x
        	# echo "$file is 2.x"
		files_2X+=($file)	

		# Increment 2.x lines counter
        	((total_lines_2X += $(wc -l < "$file")))

		# TODO: Find a way to count lines and ignore comments
   
    	elif [ -f $file ]; then
       
		# Flag as 1.0
		# echo "$file is 1.0"
		files_1X+=($file)	
	
		# Increment 1.0 lines counter
        	((total_lines_1X += $(wc -l < "$file")))		
   
    	fi
done

# Output Formatting

echo
echo "----- Code Statistics -----"
echo 

if [ output_lines ]; then
	# Print out the number of lines of both 1.0 and 2.x code.
	echo "Total #lines 1.0 code: $total_lines_1X"
	echo "Total #lines 2.x code: $total_lines_2X"
	echo 
fi

if [ output_files ]; then
	# Print out the 1.0 and 2.x file arrays
	echo "1.0 files (${#files_1X[@]} items): "
	printf "  %s\n" "${files_1X[@]}"
	echo

	echo "2.x files (${#files_2X[@]} items): " 
	printf "  %s\n" "${files_2X[@]}"
	echo
fi

echo "---------------------------"


